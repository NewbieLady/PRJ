To complete the following Merge Sort method, what merge function logic should you follow to merge two sorted halves? Pay attention to the TODO section of the merge method, where you would need to write the logic for merging two sorted subarrays. 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void mergeSort(int[] arr, int left, int right) { if (left < right) { int middle = (left + right) / 2; mergeSort(arr, left, middle); mergeSort(arr, middle + 1, right); merge(arr, left, middle, right); } } public static void merge(int[] arr, int left, int middle, int right) { // TODO: Complete the merge logic }|Create temporary arrays for the two halves, then merge them back into the original array in sorted order.
What is the pivot selection strategy in the given Quick Sort implementation? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static int partition(int[] arr, int low, int high) { int pivot = arr[low]; int left = low + 1; int right = high; while (left <= right) { while (left <= right && arr[left] <= pivot) { left++; } while (left <= right && arr[right] > pivot) { right--; } if (left < right) { int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } } arr[low] = arr[right]; arr[right] = pivot; return right; }|First element as pivot.
What's wrong with the following Quick Sort implementation? 1 2 3 4 5 6 7 8 public static void quickSort(int[] arr, int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi); quickSort(arr, pi + 1, high); } }|The first recursive call should be quickSort(arr, low, pi - 1).
In Merge Sort, what is the role of the merge() function?|Combining two sorted subarrays into one sorted array.
What is wrong with the following Merge Sort implementation, specifically in the merge() method? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static void merge(int[] arr, int left, int middle, int right) { int n1 = middle - left + 1; int n2 = right - middle; int[] leftArr = new int[n1]; int[] rightArr = new int[n2]; for (int i = 0; i < n1; i++) { leftArr[i] = arr[left + i]; } for (int j = 0; j < n2; j++) { rightArr[j] = arr[middle + 1 + j]; } int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (leftArr[i] < rightArr[j]) { arr[k++] = leftArr[i++]; } else { arr[k++] = rightArr[j++]; } } while (i < n1) { arr[k++] = leftArr[i++]; } while (j < n2) { arr[k++] = rightArr[j++]; } }|The comparison on line 16 should be leftArr[i] <= rightArr[j] to make the sorting stable.
